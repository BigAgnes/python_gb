
#Задача-1: Реализовать индексацию элементов списка не с нуля, а с 5, т.е. 5, 6, 7
#и т.д.

class MyList(list):
    def __getitem__(self, offset):
        print("(Индексация начинается с элемента [5]: => ML = {} индекс {} ".format(self, offset))
        return list.__getitem__(self, offset -5)
ML = MyList('123456789')
print(ML[5])




#Задача-2: Придумать любую структуру данных. Она должна содержать два атрибута.
#Значение одного атрибута передается в конструктор, а значение другого - определяетсяъ
#прямо в конструкторе класса. Для этой структуры данных написать метод,
#который должен выполнять какой-то функционал. Создать экземпляр класса, передать
#данные. Вызывать метод. Проверить, что находится в переменной-экземпляре класса.
#Переопределить метод __str__. Этот метод должен возвращать тот результат,
#который вы захотите. Проверить еще раз. В комментарии написать, в чем разница
#между подходом с использованием метода __str__ и без него.


class Labor_cost(list):
    def __init__(self, salary):
        self.salary = salary
        self.bonus = self.salary // 100 * 10
    def labor_cost(self):
        self.labor_cost = self.salary + self.bonus
        return self.labor_cost
    def __str__(self):
        return "Заработная плата составляет {}, оклад {}, бонус {}".format(y.labor_cost, y.salary, y.bonus)
y = Labor_cost(30000)
print(y.labor_cost())
print(y)
print(y.__str__())

#С подходом __str__ получается более красивый результат, а так же в переменной-экземпляре
#появилось значение, которое получилось после применения метода __str__


#Задача-3: Продолжить работу над задачей 2. Добавить еще один метод. Он должен
#вывзваться из экземпляра класса. В этот метод нужно передать некое значение.
#Сам метод должен ловить значение и что-то с ним делать и возвращать результат.
#Реализовать для этого метода декоратор @staticmethod


